---
title: "DNN biology evaluation"
author: "Carlos Ruiz"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    theme: united
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# Introduction

In this document, we compared the features generated by the DNN models in a whole blood dataset of two rare diseases (Kabuki and CHARGE). We designed the DNN using biological information. Thus, the first layer contained neurons connected to CpGs mapped to the same gene. In addition, we included additional neurons in this layer mapped to Cpgs from the same chromosome to account for other patterns. This first layer was followed by two dense networks that lead to a classifier. 

```{r}
library(HDF5Array)
library(SummarizedExperiment)
library(tidyverse)
library(limma)
library(pheatmap)
library(e1071)
library(meffil)
library(smotefamily)
library(knitr)
```

# Initial dataset

## Descriptives

```{r}
se <- loadHDF5SummarizedExperiment("../data/GSE97362/", prefix = "GSE97362_raw")
se$disease <- factor(se$`disease state:ch1`, levels = c("Control", "CHARGE", "Kabuki",  "CHD7 variant","KMT2D variant"))
se$sex <- ifelse(se$characteristics_ch1 == "gender: female", "female", "male")
se$age <- as.numeric(gsub("age (years): ", "", se$characteristics_ch1.1, fixed = TRUE ))

discov <- se[, ! se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
val <- se[, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort") ]
```

Our initial dataset contained `r ncol(se)` individuals and `r nrow(se)` CpGs. Of the `r ncol(se)` samples, `r sum(se$disease == "Control")` were controls, `r sum(se$disease == "CHARGE")` had CHARGE while\
`r sum(se$disease == "Kabuki")` had Kabuki. The remaining individuals had variants candidate of causing one of the diseases. We also have `r sum(se$sex == "male")` boys and `r sum(se$sex == "female")` girls.

## Overall pattern

We first explored whether there were clusters of samples with distinctive global methylation patterns. To test this, we run a PCA on this data. We only included the 40K CpGs with highest variance:

```{r}
pc_ini <- meffil.methylation.pcs(data.matrix(assay(se)), probe.range = 40000) %>%
  data.frame()
pc_ini$disease <- colData(se)[rownames(pc_ini), "disease"]
pc_ini$sex <- colData(se)[rownames(pc_ini), "sex"]
pc_ini %>% 
  ggplot(aes(x = PC1, y = PC2, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("All CpGs - Disease")

```

Some individuals have different methylation patterns in the PC2. These differences seem to be related with disease status. Therefore, we explored other principal components:

```{r}
pc_ini %>% 
  ggplot(aes(x = PC3, y = PC4, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("All CpGs - Disease")

pc_ini %>% 
  ggplot(aes(x = PC2, y = PC4, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("All CpGs - Disease")

```

We also observed some differences due to disease in PC4. When combining PC2 and PC4, we observed that PC2 differentiates CHARGE (and CHD7 variants, variants suspected of causing CHARGE) from control samples, while PC4 differentiates control samples from Kabuki (and KMT2D variants).

```{r}
pc_ini %>% 
  ggplot(aes(x = PC1, y = PC2, color = sex)) +
  geom_point() + 
  theme_bw() +
  ggtitle("All CpGs - Sex")
```

We do not observe difference between boys and girls in the first 2 PCs. Thus, the patterns of sex are weaker than the patterns of the disease.

## Application of state-of-the-art method

Before going to the CNN models, we will test how the current state-of-the-art method works in this dataset. Briefly, the current method has two steps:

1.  Define the CpGs with more different methylation values between cases and controls
2.  Use these CpGs to train a SVM model.

In the original paper, the authors had a set of samples with known disease status (labelled as CHARGE or Kabuki), and another set with suspicious variants (CHD7 or KMT2D variants). They trained the model in the samples with known status and applied it to the samples with suspicious variants. We will use the same data division.

Thus, we will use samples with known status to define the set of CpGs differentiating cases from controls and then train the SVM. We will select probes with an adjusted p-value \< 0.01 and a FC \> 0.1 (in absolute value).

### Feature selection

```{r}

diseases <- c("CHARGE", "Kabuki")
names(diseases) <- c("CHARGE", "Kabuki")

getFeatures <- function(set, disease, minFC = 0.1){
  
  set <- set[, set$disease %in% c("Control", disease)]
  set$disease <- droplevels(set$disease)
  model <- model.matrix(~ disease + sex + age, colData(set))
  
  lmF <- lmFit(assay(set[, rownames(model)]), model)
  lmFe <- eBayes(lmF)
  tabA <- topTable(lmFe, coef = 2, n = Inf)
  selTab <- subset(tabA, !is.na(logFC) & adj.P.Val < 0.01 & abs(logFC) > minFC)
  selCpGs <- rownames(selTab)
  
}
sel_cpgs <- lapply(diseases, getFeatures, set = discov)
sel_cpgs_vec <- unique(unlist(sel_cpgs))
```

A total of `r length(sel_cpgs$CHARGE)` and `r length(sel_cpgs$Kabuki)` CpGs had different methylation values in controls than in CHARGE or Kabuki, respectively.

```{r}
col_colors <- list(
  disease = c("Control" = "black", "CHARGE" = "green", "Kabuki" = "blue",
              "CHD7 variant" = "lightgreen", "KMT2D variant" = "cyan"),
  sex = c("female" = "purple", "male" = "lightblue")
)

pheatmap(assay(discov)[sel_cpgs_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(discov)[, "disease", drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

The heatmap shows that when including only these selected CpGs, control and case samples are clearly separated in the discovery dataset (dataset used for defining the CpGs). Nonetheless, we observe that CHARGE individuals are separated in two groups, with some samples more similar to control samples.

```{r}
pheatmap(assay(val)[sel_cpgs_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(val)[, "disease", drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)
```

When selecting the same CpGs in the validation dataset, we observe that samples with variants are separeted from controls. In addition, samples with CHD7 variants are separated from samples with KMT2D variants.

### SVM training

```{r}
trainSVM <-  function(set, feats){
  mat <- data.matrix(assay(set[feats, ]))
  imp_mat <- meffil:::impute.matrix(mat, margin = 1, fun = function(x) median(x, na.rm = T))
  
  df <- data.frame(pathClass = factor(set$disease), t(imp_mat))
  model_svm <- svm(pathClass ~ ., df)
}
svm_cpgs <- trainSVM(set = discov, feats = sel_cpgs_vec)

all_mat <- data.matrix(t(assay(se[sel_cpgs_vec, ])))
imp_mat <- meffil:::impute.matrix(all_mat, margin = 2, fun = function(x) median(x, na.rm = T))

pred_cpgs <- predict(svm_cpgs, imp_mat)
table(pred_cpgs, se$disease,se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))

```

The SVM model achieved a very high accuracy. Only one control samples was mislabelled and identified as CHARGE. From the individuals with candidate pathogenic variants, all but 3 were classified under their right disease. 3 individuals with CHD7 variant were classified as control.


# Dataset passed to network

## Descriptives

We explored whether we obtained the same results with the data after preprocessing for applying CNN model. 

```{r}
se_filt <- loadHDF5SummarizedExperiment("../results/preprocess/GSE97362/2021-11-18/", prefix = "GSE97362missingSub_inputProbes_")
se_filt$disease <- factor(se_filt$`disease state:ch1`, levels = c("Control", "CHARGE", "Kabuki",  "CHD7 variant","KMT2D variant"))
se_filt$sex <- ifelse(se_filt$characteristics_ch1 == "gender: female", "female", "male")
se_filt$age <- as.numeric(gsub("age (years): ", "", se_filt$characteristics_ch1.1, fixed = TRUE ))

discov_filt <- se_filt[, ! se_filt$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
val_filt <- se_filt[, se_filt$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort") ]
```

Our initial dataset contained `r ncol(se_filt)` individuals and `r nrow(se_filt)` CpGs. 

## Overall pattern

We first explored whether there were clusters of samples with distinctive global methylation patterns. To test this, we run a PCA on this data. We only included the 40K CpGs with highest variance:

```{r}
pc_ini_filt <- meffil.methylation.pcs(data.matrix(assay(se_filt)), probe.range = 40000) %>%
  data.frame()
pc_ini_filt$disease <- colData(se)[rownames(pc_ini_filt), "disease"]
pc_ini_filt$sex <- colData(se)[rownames(pc_ini_filt), "sex"]
pc_ini_filt %>% 
  ggplot(aes(x = PC1, y = PC2, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("Input CpGs model - Disease")

```

We observe some differences in the second PC.


```{r}
#lapply(1:10, function(i) summary(lm(formula(paste0("PC", i, "~ disease")), pc_ini_filt)) )
pc_ini_filt %>% 
  ggplot(aes(x = PC2, y = PC4, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("Input CpGs model - Disease")

```

We also observed some differences due to disease in PC2 and PC4. With these two components, we can differentiate some cases from controls.

```{r}
pc_ini_filt %>% 
  ggplot(aes(x = PC1, y = PC2, color = sex)) +
  geom_point() + 
  theme_bw() +
  ggtitle("Input CpGs model  - Sex")
```

We do not observe difference between boys and girls in the first 2 PCs. Thus, the patterns of sex are weaker than the patterns of the disease.

### Feature selection

```{r}
sel_cpgs_filt <- lapply(diseases, getFeatures, set = discov_filt)
sel_cpgs_filt_vec <- unique(unlist(sel_cpgs_filt))
```

A total of `r length(sel_cpgs_filt$CHARGE)` and `r length(sel_cpgs_filt$Kabuki)` CpGs had different methylation values in controls than in CHARGE or Kabuki, respectively. Some CpGs previously reported have been lost during pre-processing.

```{r}
pheatmap(assay(discov_filt)[sel_cpgs_filt_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(discov_filt)[, "disease", drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

The heatmap shows that when including only these selected CpGs, control and case samples are clearly separated in the discovery dataset (dataset used for defining the CpGs). 

```{r}
pheatmap(assay(val_filt)[sel_cpgs_filt_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(val_filt)[, "disease", drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)
```

When selecting the same CpGs in the validation dataset, we observe that samples with variants are separeted from controls. In addition, samples with CHD7 variants are separated from samples with KMT2D variants.

### SVM training

```{r}
svm_cpgs_filt <- trainSVM(set = discov_filt, feats = sel_cpgs_filt_vec)
pred_cpgs_filt <- predict(svm_cpgs_filt, t(assay(se_filt[sel_cpgs_filt_vec, ])))
table(pred_cpgs_filt, se_filt$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))

```

After preprocessing, one control sample was classified as CHARGE. For the rest, we acheived a high accuracy. Therefore, the preprocessing is not affecting the signal.

# DNN model1

## Description

We train a DNN model in TCGA whose goal was to classify samples into their tumor subtype, including all control tissues as one category. The input contained 9813 samples (80% training/20% test) and the 394,363 CpGs with variability in TCGA. Then, the model had the following layers:

```{r}
dnn_fold <- "../results/GSE97362/2021-11-17/model_features/bioDNN_v1/"
```

## First layer

This layer contains the results from the different genes and groups of CpGs from the same chromosome.

### General pattern

We first evaluated whether the output of the first layer still contained signal to differentiate the individuals by disease.

```{r}
dnn1_conc <- read_delim(paste0(dnn_fold, "concatenate.tsv"), delim = "\t")
dnn1_conc <- data.matrix(dnn1_conc)

dnn1_conc_se <- SummarizedExperiment(t(dnn1_conc), colData = colData(se))
rownames(dnn1_conc_se) <- paste0("Features", seq_len(nrow(dnn1_conc_se)))

discov_dnn1_conc <- dnn1_conc_se[, ! dnn1_conc_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
valid_dnn1_conc <- dnn1_conc_se[, dnn1_conc_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
```

We obtained `r nrow(dnn1_conc_se)` features from the first DNN layer. Of those, `r sum(!apply(dnn1_conc, 2, function(x) all(x == 0)))` had values different than 0 in at least a sample.

```{r}
pc_dnn1_conc <- prcomp(dnn1_conc)$x %>%
  data.frame()
rownames(pc_dnn1_conc) <- colnames(dnn1_conc_se)
pc_dnn1_conc$disease <- colData(se)[rownames(pc_dnn1_conc), "disease"]
pc_dnn1_conc$sex <- colData(se)[rownames(pc_dnn1_conc), "sex"]
```

```{r}
pc_dnn1_conc %>% 
  ggplot(aes(x = PC1, y = PC2, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN model layer 1 features - Disease")
```

The second PC of layer 1 features from DNN model allows us differentiating CHARGE cases from control individuals.

```{r}
pc_dnn1_conc %>% 
  ggplot(aes(x = PC2, y = PC4, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN model layer 1 features - Disease")
```

Components PC2 and PC4 of layer 1 features from DNN model  separate samples by disease type. 

```{r}
pc_dnn1_conc %>% 
  ggplot(aes(x = PC1, y = PC2, color = sex)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN model layer 1 features - Disease")
```

The first component clearly cluster samples by sex.

Summary: the features computed by the first layer in hte DNN model are capturing the difference in methylation due to sex in the first component, and the differences due to the disease in the second.

### Features selection

```{r}
sel_dnn1_conc <- lapply(diseases, getFeatures, set = discov_dnn1_conc, minFC = 0.05)
sel_dnn1_conc_vec <- unique(unlist(sel_dnn1_conc))
```

A total of `r length(sel_dnn1_conc$CHARGE)` and `r length(sel_dnn1_conc$Kabuki)` features had different methylation values in controls than in CHARGE or Kabuki, respectively.

```{r}
pheatmap(assay(discov_dnn1_conc)[sel_dnn1_conc_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(discov_dnn1_conc)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

Kabuki and control samples are clearly separated. 

```{r}
pheatmap(assay(valid_dnn1_conc)[sel_dnn1_conc_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(valid_dnn1_conc)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)
```

Individuals are clustered by disease.

### SVM training

```{r}
svm_dnn1_conc <- trainSVM(set = discov_dnn1_conc, feats = sel_dnn1_conc_vec)

pred_dnn1_conc <- predict(svm_dnn1_conc, t(assay(dnn1_conc_se)))
table(pred_dnn1_conc, se$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))

```

With this data, the SVM model presented a lower accuracy. Now, it missclassified 7 controls individuals from the training dataset, identified as cases. The classification of suspicious variants had more individuals classified as controls. Nonetheless, these results are more concordant with those published in the original paper.

Summary: The first layer of the DNN network have reduced the differences between the different disease group but it is still sufficient to classify the individuals.

## Dense layer 1 output

### General pattern

We evaluated whether the output of the dense 1 layer still contained signal to differentiate the individuals by disease.

```{r}
dnn1_dense1 <- read_delim(paste0(dnn_fold, "dense.tsv"), delim = "\t")
dnn1_dense1 <- data.matrix(dnn1_dense1)

dnn1_dense1_se <- SummarizedExperiment(t(dnn1_dense1), colData = colData(se))
rownames(dnn1_dense1_se) <- paste0("Features", seq_len(nrow(dnn1_dense1_se)))

discov_dnn1_dense1 <- dnn1_dense1_se[, ! dnn1_dense1_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
valid_dnn1_dense1 <- dnn1_dense1_se[, dnn1_dense1_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
```

We obtained `r nrow(dnn1_dense1_se)` features from the dense layer. Of those, `r sum(!apply(dnn1_dense1, 2, function(x) all(x == 0)))` had values different than 0 in at least a sample.

```{r}
pc_dnn1_dense1 <- prcomp(dnn1_dense1)$x %>%
  data.frame()
rownames(pc_dnn1_dense1) <- colnames(dnn1_dense1_se)
pc_dnn1_dense1$disease <- colData(se)[rownames(pc_dnn1_dense1), "disease"]
pc_dnn1_dense1$sex <- colData(se)[rownames(pc_dnn1_dense1), "sex"]
```

```{r}
pc_dnn1_dense1 %>% 
  ggplot(aes(x = PC1, y = PC2, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN1 model dense1 features - Disease")
```

The PC2 of the dense layer 1 of the DNN model differentiates control from CHARGE.

```{r}
pc_dnn1_dense1 %>% 
  ggplot(aes(x = PC2, y = PC3, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN1 model dense1 features - Disease")
```

Components PC2 and PC3 of features from CNN model dense1 cluster samples by disease type. Nonetheless, the clustering was better when using the all the CpGs or the layer 1 features.

```{r}
pc_dnn1_dense1 %>% 
  ggplot(aes(x = PC1, y = PC2, color = sex)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN1 model dense1 features - Sex")
```

The first component is not separating sample by sex. 

Summary: the features computed by the DNN model dense1 layer are capturing the difference in methylation due to disease rather than to sex.

### Features selection

Due to the high number of features without significant values, we remove them before selecting the features.

```{r}
sel_dnn1_dense1 <- lapply(diseases, getFeatures, set = discov_dnn1_dense1[!apply(dnn1_dense1, 2, function(x) all(x == 0)), ], minFC = 0)
sel_dnn1_dense1_vec <- unique(unlist(sel_dnn1_dense1))
```

A total of `r length(sel_dnn1_dense1$CHARGE)` and `r length(sel_dnn1_dense1$Kabuki)` features had different methylation values in controls than in CHARGE or Kabuki, respectively.

```{r}
pheatmap(assay(discov_dnn1_dense1)[sel_dnn1_dense1_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(discov_dnn1_dense1)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

Cases and controls are merged. 

```{r}
pheatmap(assay(valid_dnn1_dense1)[sel_dnn1_dense1_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(valid_dnn1_dense1)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

Some sample with variants are clearly separated from controls.

### SVM model

We repeated the SVM with the features selected in the previous step.

```{r}
svm_dnn1_dense1 <- trainSVM(set = discov_dnn1_dense1, feats = sel_dnn1_dense1_vec)

pred_dnn1_dense1 <- predict(svm_dnn1_dense1, t(assay(dnn1_dense1_se)))
table(pred_dnn1_dense1, se$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))

```

The SVM model can identify case samples but confuse some controls with case samples. The performance is still good for samples with CHARGE variants.

```{r}
svm_dnn1_dense1b <- trainSVM(set = discov_dnn1_dense1, feats = rownames(dnn1_dense1_se)[!apply(dnn1_dense1, 2, function(x) all(x == 0))])

pred_dnn1_dense1b <- predict(svm_dnn1_dense1b, t(assay(dnn1_dense1_se)))
table(pred_dnn1_dense1b, se$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))
```

When using all the features with values different than 0, we are able to classify half of the CHARGE samples with variants but not Kabuki.

Summary: The dense 1 layer still contains some information to differentiate cases and controls.

## Dense layer 2 output

### General pattern

We evaluated whether the output of the dense 2 layer still contained signal to differentiate the individuals by disease.

```{r}
dnn1_dense2 <- read_delim(paste0(dnn_fold, "dense_1.tsv"), delim = "\t")
dnn1_dense2 <- data.matrix(dnn1_dense2)

dnn1_dense2_se <- SummarizedExperiment(t(dnn1_dense2), colData = colData(se))
rownames(dnn1_dense2_se) <- paste0("Features", seq_len(nrow(dnn1_dense2_se)))

discov_dnn1_dense2 <- dnn1_dense2_se[, ! dnn1_dense2_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
valid_dnn1_dense2 <- dnn1_dense2_se[, dnn1_dense2_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
```

We obtained `r nrow(dnn1_dense2_se)` features from the dense layer. Of those, `r sum(!apply(dnn1_dense2, 2, function(x) all(x == 0)))` had values different than 0 in at least a sample.

```{r}
pc_dnn1_dense2 <- prcomp(dnn1_dense2)$x %>%
  data.frame()
rownames(pc_dnn1_dense2) <- colnames(dnn1_dense2_se)
pc_dnn1_dense2$disease <- colData(se)[rownames(pc_dnn1_dense2), "disease"]
pc_dnn1_dense2$sex <- colData(se)[rownames(pc_dnn1_dense2), "sex"]
```

```{r}
pc_dnn1_dense2 %>% 
  ggplot(aes(x = PC1, y = PC2, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN1 model dense2 features - Disease")
```

The second top PC of dense 2 features from DNN model separates charge from controls.

```{r}
pc_dnn1_dense2 %>% 
  ggplot(aes(x = PC2, y = PC3, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN1 model dense2 features - Disease")
```

Components PC2 and PC3 of features from DNN model dense2 cluster samples by disease type. Nonetheless, the clustering was better when using the all the CpGs.

```{r}
pc_dnn1_dense2 %>% 
  ggplot(aes(x = PC1, y = PC2, color = sex)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN1 model dense2 features - Disease")
```

The first component is not separating sample by sex. 

Summary: the features computed by the DNN model dense2 layer are capturing the difference in methylation due to disease rather than to sex.

### Heatmaps

We will select only those features where at least one sample has a values different than 0.

```{r}
sel_dnn1_dense2_vec <- rownames(discov_dnn1_dense2)[!apply(dnn1_dense2, 2, function(x) all(x == 0))]
```


```{r}
pheatmap(assay(discov_dnn1_dense2)[sel_dnn1_dense2_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(discov_dnn1_dense2)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

There are some cluster of case samples but they are not clearly separated from controls.
```{r}
pheatmap(assay(valid_dnn1_dense2)[sel_dnn1_dense2_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(valid_dnn1_dense2)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

Some samples with variants are separated from controls..

### SVM model

We repeated the SVM with all the features from dense 2 different than 0.

```{r}
svm_dnn1_dense2 <- trainSVM(set = discov_dnn1_dense2, feats = sel_dnn1_dense2_vec)

pred_dnn1_dense2 <- predict(svm_dnn1_dense2, t(assay(dnn1_dense2_se)))
table(pred_dnn1_dense2, se$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))

```

The SVM is struggling to differentiate the case samples even in the training set. Nonetheless, CHARGE samples with variants are correctly classified. 

Summary: The dense 2 layer still contain some information to differentiate cases and controls, although it might not be enough for correctly distinguish the individuals.

```{r}
discov_dnn1_dense2_df <- data.frame(t(assay(discov_dnn1_dense2[sel_dnn1_dense2_vec, ])))
discov_dnn1_dense2_df$class <- as.character(discov_dnn1_dense2$disease)
smoteKab <- SMOTE(discov_dnn1_dense2_df[discov_dnn1_dense2_df$class != "CHARGE", -ncol(discov_dnn1_dense2_df) ], discov_dnn1_dense2_df$class[discov_dnn1_dense2_df$class != "CHARGE"] )

smoteCharge <- SMOTE(discov_dnn1_dense2_df[discov_dnn1_dense2_df$class != "Kabuki", -ncol(discov_dnn1_dense2_df) ], discov_dnn1_dense2_df$class[discov_dnn1_dense2_df$class != "Kabuki"] )

mixTab <- rbind(smoteCharge$syn_data, smoteKab$syn_data, discov_dnn1_dense2_df)


svm_dnn1_dense2_smote <- svm(factor(class) ~ ., data = mixTab)
pred_dnn1_dense2_smote <- predict(svm_dnn1_dense2_smote, t(assay(dnn1_dense2_se)))
table(pred_dnn1_dense2_smote, se$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))

```

Increase the sample size with SMOTE is reducing the capability of detecting controls.

## TCGA data

We explored the features generated by the DNN1 model in the original TCGA data.


```{r}
tcga_fold <- "../results/TCGA_bioDNN/2021-11-18/model_features/bioDNN_v1/"
tcga1_conc <- read_delim(paste0(tcga_fold, "concatenate.tsv"), delim = "\t")
tcga1_conc <- data.matrix(tcga1_conc)
sum(!apply(tcga1_conc, 2, function(x) all(x == 0)))
```


```{r}
tcga1_dnn <- read_delim(paste0(tcga_fold, "dense.tsv"), delim = "\t")
tcga1_dnn <- data.matrix(tcga1_dnn)
sum(!apply(tcga1_dnn, 2, function(x) all(x == 0)))
```


```{r}
tcga1_dnn1 <- read_delim(paste0(tcga_fold, "dense_1.tsv"), delim = "\t")
tcga1_dnn1 <- data.matrix(tcga1_dnn1)
sum(!apply(tcga1_dnn1, 2, function(x) all(x == 0)))
```

# DNN model2

## Description

This DNN model had the same structure. The only difference is that the CpGs mapped to genes were also mapped to the neurons of their corresponding chromosome.

```{r}
dnn2_fold <- "../results/GSE97362/2021-11-18/model_features/bioDNN_v2/"
```

## First layer

This layer contains the results from the different genes and groups of CpGs from the same chromosome.

### General pattern

We first evaluated whether the output of the first layer still contained signal to differentiate the individuals by disease.

```{r}
dnn2_conc <- read_delim(paste0(dnn2_fold, "concatenate.tsv"), delim = "\t")
dnn2_conc <- data.matrix(dnn2_conc)

dnn2_conc_se <- SummarizedExperiment(t(dnn2_conc), colData = colData(se))
rownames(dnn2_conc_se) <- paste0("Features", seq_len(nrow(dnn2_conc_se)))

discov_dnn2_conc <- dnn2_conc_se[, ! dnn2_conc_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
valid_dnn2_conc <- dnn2_conc_se[, dnn2_conc_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
```

We obtained `r nrow(dnn2_conc_se)` features from the first DNN layer. Of those, `r sum(!apply(dnn2_conc, 2, function(x) all(x == 0)))` had values different than 0 in at least a sample.

```{r}
pc_dnn2_conc <- prcomp(dnn2_conc)$x %>%
  data.frame()
rownames(pc_dnn2_conc) <- colnames(dnn2_conc_se)
pc_dnn2_conc$disease <- colData(se)[rownames(pc_dnn2_conc), "disease"]
pc_dnn2_conc$sex <- colData(se)[rownames(pc_dnn2_conc), "sex"]
```

```{r}
pc_dnn2_conc %>% 
  ggplot(aes(x = PC1, y = PC2, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN2 model layer 1 features - Disease")
```

The second PC of layer 1 features from DNN model allows us differentiating CHARGE cases from control individuals.

```{r}
pc_dnn2_conc %>% 
  ggplot(aes(x = PC2, y = PC6, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN2 model layer 1 features - Disease")
```

Components PC2 and PC6 of layer 1 features from DNN model separate samples by disease type. 

```{r}
pc_dnn2_conc %>% 
  ggplot(aes(x = PC1, y = PC2, color = sex)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN2 model layer 1 features - Disease")
```

There is no correlation with sex. 

Summary: the features computed by the first layer in the DNN model are capturing the difference in methylation due to disease.

### Features selection

```{r}
sel_dnn2_conc <- lapply(diseases, getFeatures, set = discov_dnn2_conc, minFC = 0.05)
sel_dnn2_conc_vec <- unique(unlist(sel_dnn2_conc))
```

A total of `r length(sel_dnn2_conc$CHARGE)` and `r length(sel_dnn2_conc$Kabuki)` features had different methylation values in controls than in CHARGE or Kabuki, respectively.

```{r}
pheatmap(assay(discov_dnn2_conc)[sel_dnn2_conc_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(discov_dnn2_conc)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

Kabuki and control samples are clearly separated, but the separation was better for DNN1 model.

```{r}
pheatmap(assay(valid_dnn2_conc)[sel_dnn2_conc_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(valid_dnn2_conc)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)
```

Individuals are clustered by disease.

### SVM training

```{r}
svm_dnn2_conc <- trainSVM(set = discov_dnn2_conc, feats = sel_dnn2_conc_vec)

pred_dnn2_conc <- predict(svm_dnn2_conc, t(assay(dnn2_conc_se)))
table(pred_dnn2_conc, se$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))

```

These results are very similar to those from DNN1 model.

## Dense layer 1 output

### General pattern

We evaluated whether the output of the dense 1 layer still contained signal to differentiate the individuals by disease.

```{r}
dnn2_dense1 <- read_delim(paste0(dnn2_fold, "dense.tsv"), delim = "\t")
dnn2_dense1 <- data.matrix(dnn2_dense1)

dnn2_dense1_se <- SummarizedExperiment(t(dnn2_dense1), colData = colData(se))
rownames(dnn2_dense1_se) <- paste0("Features", seq_len(nrow(dnn2_dense1_se)))

discov_dnn2_dense1 <- dnn2_dense1_se[, ! dnn2_dense1_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
valid_dnn2_dense1 <- dnn2_dense1_se[, dnn2_dense1_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
```

We obtained `r nrow(dnn2_dense1_se)` features from the dense layer. Of those, `r sum(!apply(dnn2_dense1, 2, function(x) all(x == 0)))` had values different than 0 in at least a sample.

```{r}
pc_dnn2_dense1 <- prcomp(dnn2_dense1)$x %>%
  data.frame()
rownames(pc_dnn2_dense1) <- colnames(dnn2_dense1_se)
pc_dnn2_dense1$disease <- colData(se)[rownames(pc_dnn2_dense1), "disease"]
pc_dnn2_dense1$sex <- colData(se)[rownames(pc_dnn2_dense1), "sex"]
```

```{r}
pc_dnn2_dense1 %>% 
  ggplot(aes(x = PC1, y = PC2, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN2 model dense1 features - Disease")
```

The PC1 of the dense layer 1 of the DNN model differentiates control from CHARGE.

```{r}
pc_dnn2_dense1 %>% 
  ggplot(aes(x = PC1, y = PC3, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN2 model dense1 features - Disease")
```

Components PC1 and PC3 of features from CNN model dense1 cluster samples by disease type. Nonetheless, the clustering was better when using the all the CpGs or the layer 1 features.

```{r}
pc_dnn2_dense1 %>% 
  ggplot(aes(x = PC1, y = PC2, color = sex)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN2 model dense1 features - Sex")
```

The first component is not separating sample by sex. 

Summary: the features computed by the DNN model dense1 layer are capturing the difference in methylation due to disease rather than to sex.

### Features selection

Due to the high number of features without significant values, we remove them before selecting the features.

```{r}
sel_dnn2_dense1 <- lapply(diseases, getFeatures, set = discov_dnn2_dense1[!apply(dnn2_dense1, 2, function(x) all(x == 0)), ], minFC = 0)
sel_dnn2_dense1_vec <- unique(unlist(sel_dnn2_dense1))
```

A total of `r length(sel_dnn2_dense1$CHARGE)` and `r length(sel_dnn2_dense1$Kabuki)` features had different methylation values in controls than in CHARGE or Kabuki, respectively.

```{r}
pheatmap(assay(discov_dnn2_dense1)[sel_dnn2_dense1_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(discov_dnn2_dense1)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

Cases and controls are not completely separated.

```{r}
pheatmap(assay(valid_dnn2_dense1)[sel_dnn2_dense1_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(valid_dnn2_dense1)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

Some sample with variants are clearly separated from controls.

### SVM model

We repeated the SVM with the features selected in the previous step.

```{r}
svm_dnn2_dense1 <- trainSVM(set = discov_dnn2_dense1, feats = sel_dnn2_dense1_vec)

pred_dnn2_dense1 <- predict(svm_dnn2_dense1, t(assay(dnn2_dense1_se)))
table(pred_dnn2_dense1, se$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))

```

The performance is much worse than for model 1. A lot of controls are classified as Kabuki.

```{r}
svm_dnn2_dense1b <- trainSVM(set = discov_dnn2_dense1, feats = rownames(dnn2_dense1_se)[!apply(dnn2_dense1, 2, function(x) all(x == 0))])

pred_dnn2_dense1b <- predict(svm_dnn2_dense1b, t(assay(dnn2_dense1_se)))
table(pred_dnn2_dense1b, se$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))
```

When using all the features with values different than 0, we are able to classify half of the CHARGE samples with variants but not Kabuki. This is better than selection the top features. In this case, DNN2 model is improving DNN1 model.

Summary: The dense 1 layer still contains some information to differentiate cases and controls.

## Dense layer 2 output

### General pattern

We evaluated whether the output of the dense 2 layer still contained signal to differentiate the individuals by disease.

```{r}
dnn2_dense2 <- read_delim(paste0(dnn2_fold, "dense_1.tsv"), delim = "\t")
dnn2_dense2 <- data.matrix(dnn2_dense2)

dnn2_dense2_se <- SummarizedExperiment(t(dnn2_dense2), colData = colData(se))
rownames(dnn2_dense2_se) <- paste0("Features", seq_len(nrow(dnn2_dense2_se)))

discov_dnn2_dense2 <- dnn2_dense2_se[, ! dnn2_dense2_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
valid_dnn2_dense2 <- dnn2_dense2_se[, dnn2_dense2_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
```

We obtained `r nrow(dnn2_dense2_se)` features from the dense layer. Of those, `r sum(!apply(dnn2_dense2, 2, function(x) all(x == 0)))` had values different than 0 in at least a sample.

```{r}
pc_dnn2_dense2 <- prcomp(dnn2_dense2)$x %>%
  data.frame()
rownames(pc_dnn2_dense2) <- colnames(dnn2_dense2_se)
pc_dnn2_dense2$disease <- colData(se)[rownames(pc_dnn2_dense2), "disease"]
pc_dnn2_dense2$sex <- colData(se)[rownames(pc_dnn2_dense2), "sex"]
```

```{r}
pc_dnn2_dense2 %>% 
  ggplot(aes(x = PC1, y = PC2, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN2 model dense2 features - Disease")
```

The first two PCs from DNN2 model separates charge from controls. Nonetheless, the clustering was better when using the all the CpGs.

```{r}
pc_dnn2_dense2 %>% 
  ggplot(aes(x = PC1, y = PC2, color = sex)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN2 model dense2 features - Disease")
```

The first component is not separating sample by sex. 

Summary: the features computed by the DNN2 model dense2 layer are capturing the difference in methylation due to disease rather than to sex.

### Heatmaps

We will select only those features where at least one sample has a values different than 0.

```{r}
sel_dnn2_dense2_vec <- rownames(discov_dnn2_dense2)[!apply(dnn2_dense2, 2, function(x) all(x == 0))]
```


```{r}
pheatmap(assay(discov_dnn2_dense2)[sel_dnn2_dense2_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(discov_dnn2_dense2)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

There are some cluster of case samples but they are not clearly separated from controls.

```{r}
pheatmap(assay(valid_dnn2_dense2)[sel_dnn2_dense2_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(valid_dnn2_dense2)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

Some samples with variants are separated from controls.

### SVM model

We repeated the SVM with all the features from dense 2 different than 0.

```{r}
svm_dnn2_dense2 <- trainSVM(set = discov_dnn2_dense2, feats = sel_dnn2_dense2_vec)

pred_dnn2_dense2 <- predict(svm_dnn2_dense2, t(assay(dnn2_dense2_se)))
table(pred_dnn2_dense2, se$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))

```

The SVM fails to differentiate cases from controls. This step works much worse than for DNN1 model.


```{r}
discov_dnn2_dense2_df <- data.frame(t(assay(discov_dnn2_dense2[sel_dnn2_dense2_vec, ])))
discov_dnn2_dense2_df$class <- as.character(discov_dnn2_dense2$disease)
smoteKab <- SMOTE(discov_dnn2_dense2_df[discov_dnn2_dense2_df$class != "CHARGE", -ncol(discov_dnn2_dense2_df) ], discov_dnn2_dense2_df$class[discov_dnn2_dense2_df$class != "CHARGE"] )

smoteCharge <- SMOTE(discov_dnn2_dense2_df[discov_dnn2_dense2_df$class != "Kabuki", -ncol(discov_dnn2_dense2_df) ], discov_dnn2_dense2_df$class[discov_dnn2_dense2_df$class != "Kabuki"] )

mixTab <- rbind(smoteCharge$syn_data, smoteKab$syn_data, discov_dnn2_dense2_df)


svm_dnn2_dense2_smote <- svm(factor(class) ~ ., data = mixTab)
pred_dnn2_dense2_smote <- predict(svm_dnn2_dense2_smote, t(assay(dnn2_dense2_se)))
table(pred_dnn2_dense2_smote, se$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))

```

Increase the sample size with SMOTE is reducing the capability of detecting controls.


# DNN model3

## Description

This DNN model had the same structure than DNN model1 but with one neuron per gene, and 1000 per chromosome.


```{r}
dnn3_fold <- "../results/GSE97362/2021-11-22/model_features/bioDNN_v3/"
```

## First layer

This layer contains the results from the different genes and groups of CpGs from the same chromosome.

### General pattern

We first evaluated whether the output of the first layer still contained signal to differentiate the individuals by disease.

```{r}
dnn3_conc <- read_delim(paste0(dnn3_fold, "concatenate.tsv"), delim = "\t")
dnn3_conc <- data.matrix(dnn3_conc)

dnn3_conc_se <- SummarizedExperiment(t(dnn3_conc), colData = colData(se))
rownames(dnn3_conc_se) <- paste0("Features", seq_len(nrow(dnn3_conc_se)))

discov_dnn3_conc <- dnn3_conc_se[, ! dnn3_conc_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
valid_dnn3_conc <- dnn3_conc_se[, dnn3_conc_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
```

We obtained `r nrow(dnn3_conc_se)` features from the first DNN layer. Of those, `r sum(!apply(dnn3_conc, 2, function(x) all(x == 0)))` had values different than 0 in at least a sample.

```{r}
pc_dnn3_conc <- prcomp(dnn3_conc)$x %>%
  data.frame()
rownames(pc_dnn3_conc) <- colnames(dnn3_conc_se)
pc_dnn3_conc$disease <- colData(se)[rownames(pc_dnn3_conc), "disease"]
pc_dnn3_conc$sex <- colData(se)[rownames(pc_dnn3_conc), "sex"]
```

```{r}
pc_dnn3_conc %>% 
  ggplot(aes(x = PC1, y = PC2, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN3 model layer 1 features - Disease")
```

The second PC of layer 1 features from DNN model allows us differentiating CHARGE cases from control individuals.

```{r}
pc_dnn3_conc %>% 
  ggplot(aes(x = PC2, y = PC4, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN3 model layer 1 features - Disease")
```

Components PC2 and PC4 of layer 1 features from DNN model  separate samples by disease type. 

```{r}
pc_dnn3_conc %>% 
  ggplot(aes(x = PC1, y = PC2, color = sex)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN model layer 1 features - Disease")
```

The first two components does not cluster samples by sex.

Summary: the features computed by the first layer in the DNN model are capturing the differences due to the disease in the first four components.

### Features selection

```{r}
sel_dnn3_conc <- lapply(diseases, getFeatures, set = discov_dnn3_conc, minFC = 0.05)
sel_dnn3_conc_vec <- unique(unlist(sel_dnn3_conc))
```

A total of `r length(sel_dnn3_conc$CHARGE)` and `r length(sel_dnn3_conc$Kabuki)` features had different methylation values in controls than in CHARGE or Kabuki, respectively.

```{r}
pheatmap(assay(discov_dnn3_conc)[sel_dnn3_conc_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(discov_dnn3_conc)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

Kabuki and control samples are clearly separated. 

```{r}
pheatmap(assay(valid_dnn3_conc)[sel_dnn3_conc_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(valid_dnn3_conc)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)
```

Individuals are clustered by disease.

### SVM training

```{r}
svm_dnn3_conc <- trainSVM(set = discov_dnn3_conc, feats = sel_dnn3_conc_vec)

pred_dnn3_conc <- predict(svm_dnn3_conc, t(assay(dnn3_conc_se)))
table(pred_dnn3_conc, se$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))

```

With this data, the SVM model presented a lower accuracy. Now, it missclassified 6 controls individuals from the training dataset, identified as cases. In the test dataset, 25% of CHARGE samples were identified as controls. 

Summary: The first layer of the DNN network have reduced the differences between the different disease group but it is still sufficient to classify the individuals.

## Dense layer 1 output

### General pattern

We evaluated whether the output of the dense 1 layer still contained signal to differentiate the individuals by disease.

```{r}
dnn3_dense1 <- read_delim(paste0(dnn3_fold, "dense.tsv"), delim = "\t")
dnn3_dense1 <- data.matrix(dnn3_dense1)

dnn3_dense1_se <- SummarizedExperiment(t(dnn3_dense1), colData = colData(se))
rownames(dnn3_dense1_se) <- paste0("Features", seq_len(nrow(dnn3_dense1_se)))

discov_dnn3_dense1 <- dnn3_dense1_se[, ! dnn3_dense1_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
valid_dnn3_dense1 <- dnn3_dense1_se[, dnn3_dense1_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
```

We obtained `r nrow(dnn3_dense1_se)` features from the dense layer. Of those, `r sum(!apply(dnn3_dense1, 2, function(x) all(x == 0)))` had values different than 0 in at least a sample.

```{r}
pc_dnn3_dense1 <- prcomp(dnn3_dense1)$x %>%
  data.frame()
rownames(pc_dnn3_dense1) <- colnames(dnn3_dense1_se)
pc_dnn3_dense1$disease <- colData(se)[rownames(pc_dnn3_dense1), "disease"]
pc_dnn3_dense1$sex <- colData(se)[rownames(pc_dnn3_dense1), "sex"]
```

```{r}
pc_dnn3_dense1 %>% 
  ggplot(aes(x = PC1, y = PC2, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("dnn3 model dense1 features - Disease")
```

The first 2 PCs have less differences between cases and controls.

```{r}
pc_dnn3_dense1 %>% 
  ggplot(aes(x = PC3, y = PC4, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN3 model dense1 features - Disease")
```

Components PC3 and PC4 of features from DNN model3 dense1 cluster samples by disease type. Nonetheless, the clustering was better when using the all the CpGs or the layer 1 features.

```{r}
pc_dnn3_dense1 %>% 
  ggplot(aes(x = PC1, y = PC2, color = sex)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN3 model dense1 features - Sex")
```

The first component is not separating sample by sex. 

Summary: the features computed by the DNN3 model dense1 layer are capturing the difference in methylation due to disease rather than to sex.

### Features selection

Due to the high number of features without significant values, we remove them before selecting the features.

```{r}
sel_dnn3_dense1 <- lapply(diseases, getFeatures, set = discov_dnn3_dense1[!apply(dnn3_dense1, 2, function(x) all(x == 0)), ], minFC = 0)
sel_dnn3_dense1_vec <- unique(unlist(sel_dnn3_dense1))
```

A total of `r length(sel_dnn3_dense1$CHARGE)` and `r length(sel_dnn3_dense1$Kabuki)` features had different methylation values in controls than in CHARGE or Kabuki, respectively.

```{r}
pheatmap(assay(discov_dnn3_dense1)[sel_dnn3_dense1_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(discov_dnn3_dense1)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

Kabuki and CHARGE samples are separated but are merged with other control samples.

```{r}
pheatmap(assay(valid_dnn3_dense1)[sel_dnn3_dense1_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(valid_dnn3_dense1)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

Some samples with variants are clearly separated from controls.

### SVM model

We repeated the SVM with the features selected in the previous step.

```{r}
svm_dnn3_dense1 <- trainSVM(set = discov_dnn3_dense1, feats = sel_dnn3_dense1_vec)

pred_dnn3_dense1 <- predict(svm_dnn3_dense1, t(assay(dnn3_dense1_se)))
table(pred_dnn3_dense1, se$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))

```

The SVM model can identify case samples but confuse some controls with case samples. The performance is still good for samples with Kabuki variants.

```{r}
svm_dnn3_dense1b <- trainSVM(set = discov_dnn3_dense1, feats = rownames(dnn3_dense1_se)[!apply(dnn3_dense1, 2, function(x) all(x == 0))])

pred_dnn3_dense1b <- predict(svm_dnn3_dense1b, t(assay(dnn3_dense1_se)))
table(pred_dnn3_dense1b, se$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))
```

When using all the features with values different than 0, we improve the classification for both CHARGE and Kabuki. Nonetheless, the accuracy is around 50%.

Summary: The dense 1 layer still contains some information to differentiate cases and controls.

## Dense layer 2 output

### General pattern

We evaluated whether the output of the dense 2 layer still contained signal to differentiate the individuals by disease.

```{r}
dnn3_dense2 <- read_delim(paste0(dnn3_fold, "dense_1.tsv"), delim = "\t")
dnn3_dense2 <- data.matrix(dnn3_dense2)

dnn3_dense2_se <- SummarizedExperiment(t(dnn3_dense2), colData = colData(se))
rownames(dnn3_dense2_se) <- paste0("Features", seq_len(nrow(dnn3_dense2_se)))

discov_dnn3_dense2 <- dnn3_dense2_se[, ! dnn3_dense2_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
valid_dnn3_dense2 <- dnn3_dense2_se[, dnn3_dense2_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
```

We obtained `r nrow(dnn3_dense2_se)` features from the dense layer. Of those, `r sum(!apply(dnn3_dense2, 2, function(x) all(x == 0)))` had values different than 0 in at least a sample.

```{r}
pc_dnn3_dense2 <- prcomp(dnn3_dense2)$x %>%
  data.frame()
rownames(pc_dnn3_dense2) <- colnames(dnn3_dense2_se)
pc_dnn3_dense2$disease <- colData(se)[rownames(pc_dnn3_dense2), "disease"]
pc_dnn3_dense2$sex <- colData(se)[rownames(pc_dnn3_dense2), "sex"]
```

```{r}
pc_dnn3_dense2 %>% 
  ggplot(aes(x = PC1, y = PC2, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN3 model dense2 features - Disease")
```

The first two PCs do not have much information to separate cases from controls.

```{r}
pc_dnn3_dense2 %>% 
  ggplot(aes(x = PC3, y = PC5, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN3 model dense2 features - Disease")
```

Components PC3 and PC5 of features from DNN3 model dense2 cluster samples by disease type. Nonetheless, the clustering was better when using the all the CpGs.

```{r}
pc_dnn3_dense2 %>% 
  ggplot(aes(x = PC1, y = PC2, color = sex)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN3 model dense2 features - Disease")
```

The first component is not separating sample by sex. 

Summary: the features computed by the DNN3 model dense2 layer are capturing the difference in methylation due to disease rather than to sex.

### Heatmaps

We will select only those features where at least one sample has a values different than 0.

```{r}
sel_dnn3_dense2_vec <- rownames(discov_dnn3_dense2)[!apply(dnn3_dense2, 2, function(x) all(x == 0))]
```


```{r}
pheatmap(assay(discov_dnn3_dense2)[sel_dnn3_dense2_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(discov_dnn3_dense2)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

There are some cluster of case samples but they are not clearly separated from controls.

```{r}
pheatmap(assay(valid_dnn3_dense2)[sel_dnn3_dense2_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(valid_dnn3_dense2)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

Some samples with variants are separated from controls.

### SVM model

We repeated the SVM with all the features from dense 2 different than 0.

```{r}
svm_dnn3_dense2 <- trainSVM(set = discov_dnn3_dense2, feats = sel_dnn3_dense2_vec)

pred_dnn3_dense2 <- predict(svm_dnn3_dense2, t(assay(dnn3_dense2_se)))
table(pred_dnn3_dense2, se$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))

```

The SVM is not able to differentiate case samples even in the training set. Therefore, it fails to classify any sample in the validation set.

Summary: The dense 2 layer still contain some information to differentiate cases and controls, although it might not be enough for correctly distinguish the individuals.

```{r}
discov_dnn3_dense2_df <- data.frame(t(assay(discov_dnn3_dense2[sel_dnn3_dense2_vec, ])))
discov_dnn3_dense2_df$class <- as.character(discov_dnn3_dense2$disease)
smoteKab <- SMOTE(discov_dnn3_dense2_df[discov_dnn3_dense2_df$class != "CHARGE", -ncol(discov_dnn3_dense2_df) ], discov_dnn3_dense2_df$class[discov_dnn3_dense2_df$class != "CHARGE"] )

smoteCharge <- SMOTE(discov_dnn3_dense2_df[discov_dnn3_dense2_df$class != "Kabuki", -ncol(discov_dnn3_dense2_df) ], discov_dnn3_dense2_df$class[discov_dnn3_dense2_df$class != "Kabuki"] )

mixTab <- rbind(smoteCharge$syn_data, smoteKab$syn_data, discov_dnn3_dense2_df)


svm_dnn3_dense2_smote <- svm(factor(class) ~ ., data = mixTab)
pred_dnn3_dense2_smote <- predict(svm_dnn3_dense2_smote, t(assay(dnn3_dense2_se)))
table(pred_dnn3_dense2_smote, se$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))

```

Increase the sample size with SMOTE improves the ability to classify Kabuki samples but the specificity is reduced. The accuracy for CHARGE samples remains low.

## TCGA data

We explored the features generated by the DNN3 model in the original TCGA data.


```{r}
tcga3_fold <- "../results/TCGA_bioDNN/2021-11-21/model_features/bioDNN_v3/"
tcga3_conc <- read_delim(paste0(tcga3_fold, "concatenate.tsv"), delim = "\t")
tcga3_conc <- data.matrix(tcga3_conc)
sum(!apply(tcga3_conc, 2, function(x) all(x == 0)))
```
`r round(mean(!apply(tcga3_conc, 2, function(x) all(x == 0)))*100, 1)`% of features of layer1 have meaningful values in TCGA.



```{r}
tcga3_dnn <- read_delim(paste0(tcga3_fold, "dense.tsv"), delim = "\t")
tcga3_dnn <- data.matrix(tcga3_dnn)
sum(!apply(tcga3_dnn, 2, function(x) all(x == 0)))
```

`r round(mean(!apply(tcga3_dnn, 2, function(x) all(x == 0)))*100, 1)`% of features of dense layer 1 have meaningful values in TCGA.


```{r}
tcga3_dnn1 <- read_delim(paste0(tcga3_fold, "dense_1.tsv"), delim = "\t")
tcga3_dnn1 <- data.matrix(tcga3_dnn1)
sum(!apply(tcga3_dnn1, 2, function(x) all(x == 0)))
```
`r round(mean(!apply(tcga3_dnn1, 2, function(x) all(x == 0)))*100, 1)`% of features of dense layer 2 have meaningful values in TCGA.


# DNN model4

## Description


This DNN model had the same structure than DNN model3 but connecting all CpGs to the chromosome neurons.

```{r}
dnn4_fold <- "../results/GSE97362/2021-11-21/model_features/bioDNN_v4/"
```

## First layer

This layer contains the results from the different genes and groups of CpGs from the same chromosome.

### General pattern

We first evaluated whether the output of the first layer still contained signal to differentiate the individuals by disease.

```{r}
dnn4_conc <- read_delim(paste0(dnn4_fold, "concatenate.tsv"), delim = "\t")
dnn4_conc <- data.matrix(dnn4_conc)

dnn4_conc_se <- SummarizedExperiment(t(dnn4_conc), colData = colData(se))
rownames(dnn4_conc_se) <- paste0("Features", seq_len(nrow(dnn4_conc_se)))

discov_dnn4_conc <- dnn4_conc_se[, ! dnn4_conc_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
valid_dnn4_conc <- dnn4_conc_se[, dnn4_conc_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
```

We obtained `r nrow(dnn4_conc_se)` features from the first DNN layer. Of those, `r sum(!apply(dnn4_conc, 2, function(x) all(x == 0)))` had values different than 0 in at least a sample.

```{r}
pc_dnn4_conc <- prcomp(dnn4_conc)$x %>%
  data.frame()
rownames(pc_dnn4_conc) <- colnames(dnn4_conc_se)
pc_dnn4_conc$disease <- colData(se)[rownames(pc_dnn4_conc), "disease"]
pc_dnn4_conc$sex <- colData(se)[rownames(pc_dnn4_conc), "sex"]
```

```{r}
pc_dnn4_conc %>% 
  ggplot(aes(x = PC1, y = PC2, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN4 model layer 1 features - Disease")
```

The first PC of layer 1 features from DNN model allows us differentiating CHARGE cases from control individuals.

```{r}
pc_dnn4_conc %>% 
  ggplot(aes(x = PC1, y = PC5, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN model layer 1 features - Disease")
```

Components PC1 and PC5 of layer 1 features from DNN model4  separate samples by disease type. 

```{r}
pc_dnn4_conc %>% 
  ggplot(aes(x = PC1, y = PC2, color = sex)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN4 model layer 1 features - Sex")
```

The first component does not cluster samples by sex.

Summary: the features computed by the first layer in hte DNN model are capturing the differences due to the disease.

### Features selection

```{r}
sel_dnn4_conc <- lapply(diseases, getFeatures, set = discov_dnn4_conc, minFC = 0.05)
sel_dnn4_conc_vec <- unique(unlist(sel_dnn4_conc))
```

A total of `r length(sel_dnn4_conc$CHARGE)` and `r length(sel_dnn4_conc$Kabuki)` features had different methylation values in controls than in CHARGE or Kabuki, respectively.

```{r}
pheatmap(assay(discov_dnn4_conc)[sel_dnn4_conc_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(discov_dnn4_conc)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

Kabuki and control samples are clearly separated. 

```{r}
pheatmap(assay(valid_dnn4_conc)[sel_dnn4_conc_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(valid_dnn4_conc)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)
```

Individuals are clustered by disease.

### SVM training

```{r}
svm_dnn4_conc <- trainSVM(set = discov_dnn4_conc, feats = sel_dnn4_conc_vec)

pred_dnn4_conc <- predict(svm_dnn4_conc, t(assay(dnn4_conc_se)))
table(pred_dnn4_conc, se$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))

```

With this data, the SVM model presented a lower accuracy than all CpGs, but a higher accuracy than other model. Only 4 controls were identified as CHARGE while 5 cases as controls. 

Summary: The first layer of the DNN network have reduced the differences between the different disease group but it is still sufficient to classify the individuals.

## Dense layer 1 output

### General pattern

We evaluated whether the output of the dense 1 layer still contained signal to differentiate the individuals by disease.

```{r}
dnn4_dense1 <- read_delim(paste0(dnn4_fold, "dense.tsv"), delim = "\t")
dnn4_dense1 <- data.matrix(dnn4_dense1)

dnn4_dense1_se <- SummarizedExperiment(t(dnn4_dense1), colData = colData(se))
rownames(dnn4_dense1_se) <- paste0("Features", seq_len(nrow(dnn4_dense1_se)))

discov_dnn4_dense1 <- dnn4_dense1_se[, ! dnn4_dense1_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
valid_dnn4_dense1 <- dnn4_dense1_se[, dnn4_dense1_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
```

We obtained `r nrow(dnn4_dense1_se)` features from the dense layer. Of those, `r sum(!apply(dnn4_dense1, 2, function(x) all(x == 0)))` had values different than 0 in at least a sample.

```{r}
pc_dnn4_dense1 <- prcomp(dnn4_dense1)$x %>%
  data.frame()
rownames(pc_dnn4_dense1) <- colnames(dnn4_dense1_se)
pc_dnn4_dense1$disease <- colData(se)[rownames(pc_dnn4_dense1), "disease"]
pc_dnn4_dense1$sex <- colData(se)[rownames(pc_dnn4_dense1), "sex"]
```

```{r}
pc_dnn4_dense1 %>% 
  ggplot(aes(x = PC1, y = PC2, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN4 model dense1 features - Disease")
```

The first 2 PCs does not allow differentiating cases from controls.

```{r}
pc_dnn4_dense1 %>% 
  ggplot(aes(x = PC2, y = PC3, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN4 model dense1 features - Disease")
```

Components PC2 and PC3 of features from DNN model4 dense1 cluster samples by disease type. Nonetheless, the clustering was better when using the all the CpGs or the layer 1 features.

```{r}
pc_dnn4_dense1 %>% 
  ggplot(aes(x = PC1, y = PC2, color = sex)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN1 model dense1 features - Sex")
```

The first component is not separating sample by sex. 

Summary: the features computed by the DNN model dense1 layer are capturing the difference in methylation due to disease rather than to sex.

### Features selection

Due to the high number of features without significant values, we remove them before selecting the features.

```{r}
sel_dnn4_dense1 <- lapply(diseases, getFeatures, set = discov_dnn4_dense1[!apply(dnn4_dense1, 2, function(x) all(x == 0)), ], minFC = 0)
sel_dnn4_dense1_vec <- unique(unlist(sel_dnn4_dense1))
```

A total of `r length(sel_dnn4_dense1$CHARGE)` and `r length(sel_dnn4_dense1$Kabuki)` features had different methylation values in controls than in CHARGE or Kabuki, respectively.

```{r}
pheatmap(assay(discov_dnn4_dense1)[sel_dnn4_dense1_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(discov_dnn4_dense1)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

Kabuki and CHARGE samples are in two groups, but they are merged with other control samples.

```{r}
pheatmap(assay(valid_dnn4_dense1)[sel_dnn4_dense1_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(valid_dnn4_dense1)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

CHARGE samples with variants are in a separate cluster. 

### SVM model

We repeated the SVM with the features selected in the previous step.

```{r}
svm_dnn4_dense1 <- trainSVM(set = discov_dnn4_dense1, feats = sel_dnn4_dense1_vec)

pred_dnn4_dense1 <- predict(svm_dnn4_dense1, t(assay(dnn4_dense1_se)))
table(pred_dnn4_dense1, se$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))

```

The SVM model can identify case samples but confuse some controls with case samples. The performance is still good for samples with CHARGE variants.

```{r}
svm_dnn4_dense1b <- trainSVM(set = discov_dnn4_dense1, feats = rownames(dnn4_dense1_se)[!apply(dnn4_dense1, 2, function(x) all(x == 0))])

pred_dnn4_dense1b <- predict(svm_dnn4_dense1b, t(assay(dnn4_dense1_se)))
table(pred_dnn4_dense1b, se$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))
```

When using all the features with values different than 0, the performance is reduced.

Summary: The dense 1 layer still contains some information to differentiate cases and controls.

## Dense layer 2 output

### General pattern

We evaluated whether the output of the dense 2 layer still contained signal to differentiate the individuals by disease.

```{r}
dnn4_dense2 <- read_delim(paste0(dnn4_fold, "dense_1.tsv"), delim = "\t")
dnn4_dense2 <- data.matrix(dnn4_dense2)

dnn4_dense2_se <- SummarizedExperiment(t(dnn4_dense2), colData = colData(se))
rownames(dnn4_dense2_se) <- paste0("Features", seq_len(nrow(dnn4_dense2_se)))

discov_dnn4_dense2 <- dnn4_dense2_se[, ! dnn4_dense2_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
valid_dnn4_dense2 <- dnn4_dense2_se[, dnn4_dense2_se$`sample type:ch1`  %in% c("Control for validation cohort",  "Validation cohort") ]
```

We obtained `r nrow(dnn4_dense2_se)` features from the dense layer. Of those, `r sum(!apply(dnn4_dense2, 2, function(x) all(x == 0)))` had values different than 0 in at least a sample.

```{r}
pc_dnn4_dense2 <- prcomp(dnn4_dense2)$x %>%
  data.frame()
rownames(pc_dnn4_dense2) <- colnames(dnn4_dense2_se)
pc_dnn4_dense2$disease <- colData(se)[rownames(pc_dnn4_dense2), "disease"]
pc_dnn4_dense2$sex <- colData(se)[rownames(pc_dnn4_dense2), "sex"]
```

```{r}
pc_dnn4_dense2 %>% 
  ggplot(aes(x = PC1, y = PC2, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN4 model dense2 features - Disease")
```

We do not observe much difference in the first two PCs.
```{r}
pc_dnn4_dense2 %>% 
  ggplot(aes(x = PC2, y = PC3, color = disease)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN4 model dense2 features - Disease")
```

Components PC2 and PC3 of features from DNN4 model dense2 cluster samples by disease type. Nonetheless, the clustering was better when using the all the CpGs.

```{r}
pc_dnn4_dense2 %>% 
  ggplot(aes(x = PC1, y = PC2, color = sex)) +
  geom_point() + 
  theme_bw() +
  ggtitle("DNN1 model dense2 features - Disease")
```

The first component is not separating sample by sex. 

Summary: the features computed by the DNN model dense2 layer are capturing the difference in methylation due to disease rather than to sex.

### Heatmaps

We will select only those features where at least one sample has a values different than 0.

```{r}
sel_dnn4_dense2_vec <- rownames(discov_dnn4_dense2)[!apply(dnn4_dense2, 2, function(x) all(x == 0))]
```


```{r}
pheatmap(assay(discov_dnn4_dense2)[sel_dnn4_dense2_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(discov_dnn4_dense2)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

There are some cluster of case samples but they are not clearly separated from controls.
```{r}
pheatmap(assay(valid_dnn4_dense2)[sel_dnn4_dense2_vec, ], scale = "none", 
         annotation_col  = data.frame(colData(valid_dnn4_dense2)[, c("disease", "sex"), drop = FALSE]),
         annotation_colors =  col_colors, 
         show_rownames = FALSE)

```

Some samples with variants are separated from controls.

### SVM model

We repeated the SVM with all the features from dense 2 different than 0.

```{r}
svm_dnn4_dense2 <- trainSVM(set = discov_dnn4_dense2, feats = sel_dnn4_dense2_vec)

pred_dnn4_dense2 <- predict(svm_dnn4_dense2, t(assay(dnn4_dense2_se)))
table(pred_dnn4_dense2, se$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))

```

The SVM is struggling to differentiate the case samples even in the training set. Thus, we are not separating cases from controls.


```{r}
discov_dnn4_dense2_df <- data.frame(t(assay(discov_dnn4_dense2[sel_dnn4_dense2_vec, ])))
discov_dnn4_dense2_df$class <- as.character(discov_dnn4_dense2$disease)
smoteKab <- SMOTE(discov_dnn4_dense2_df[discov_dnn4_dense2_df$class != "CHARGE", -ncol(discov_dnn4_dense2_df) ], discov_dnn4_dense2_df$class[discov_dnn4_dense2_df$class != "CHARGE"] )

smoteCharge <- SMOTE(discov_dnn4_dense2_df[discov_dnn4_dense2_df$class != "Kabuki", -ncol(discov_dnn4_dense2_df) ], discov_dnn4_dense2_df$class[discov_dnn4_dense2_df$class != "Kabuki"] )

mixTab <- rbind(smoteCharge$syn_data, smoteKab$syn_data, discov_dnn4_dense2_df)


svm_dnn4_dense2_smote <- svm(factor(class) ~ ., data = mixTab)
pred_dnn4_dense2_smote <- predict(svm_dnn4_dense2_smote, t(assay(dnn4_dense2_se)))
table(pred_dnn4_dense2_smote, se$disease, se$`sample type:ch1` %in% c("Control for validation cohort",  "Validation cohort"))

```

Increasing the sample size with SMOTE leads to detecting most samples as Kabuki.

## TCGA data

We explored the features generated by the DNN4 model in the original TCGA data.


```{r}
tcga4_fold <- "../results/TCGA_bioDNN/2021-11-22/model_features/bioDNN_v4/"
tcga4_conc <- read_delim(paste0(tcga4_fold, "concatenate.tsv"), delim = "\t")
tcga4_conc <- data.matrix(tcga4_conc)
sum(!apply(tcga4_conc, 2, function(x) all(x == 0)))
```
`r round(mean(!apply(tcga4_conc, 2, function(x) all(x == 0)))*100, 1)`% of features of layer1 have meaningful values in TCGA.



```{r}
tcga4_dnn <- read_delim(paste0(tcga4_fold, "dense.tsv"), delim = "\t")
tcga4_dnn <- data.matrix(tcga4_dnn)
sum(!apply(tcga4_dnn, 2, function(x) all(x == 0)))
```

`r round(mean(!apply(tcga4_dnn, 2, function(x) all(x == 0)))*100, 1)`% of features of dense layer 1 have meaningful values in TCGA.


```{r}
tcga4_dnn1 <- read_delim(paste0(tcga4_fold, "dense_1.tsv"), delim = "\t")
tcga4_dnn1 <- data.matrix(tcga4_dnn1)
sum(!apply(tcga4_dnn1, 2, function(x) all(x == 0)))
```
`r round(mean(!apply(tcga4_dnn1, 2, function(x) all(x == 0)))*100, 1)`% of features of dense layer 2 have meaningful values in TCGA.



# Summary of all models

```{r}
getTab <- function(inf_class, real_class, type){
  
  logvec <- type %in% c("Control for validation cohort",  "Validation cohort")
  tab <- table(inf_class[logvec], droplevels(real_class[logvec]))
  tab
}
getAccuracy <- function(inf_class, real_class, type){
  tab <- getTab(inf_class, real_class, type)
  round(sum(diag(tab))/sum(tab), 2)
}
getSP <- function(inf_class, real_class, type){
  tab <- getTab(inf_class, real_class, type)
  round(tab[1, 1]/sum(tab[, 1]), 2)
}

getSN <- function(inf_class, real_class, type, ncol){
  tab <- getTab(inf_class, real_class, type)
  round(tab[ncol, ncol]/sum(tab[, ncol]), 2)
}
```


```{r}
df_cpgs <- data.frame(models = c("All CpGs", "TCGA CpGs"), 
                 description = c("All CpGs from GEO", "CpGs after TCGA filtering"),
                 N_CpGs = c(nrow(se), nrow(se_filt)),
                 sel_CpGs = c(length(sel_cpgs_vec), length(sel_cpgs_filt_vec)),
                 accuracy = c(getAccuracy(pred_cpgs, se$disease,se$`sample type:ch1`), 
                              getAccuracy(pred_cpgs_filt, se$disease,se$`sample type:ch1`)),
                 SP = c(getSP(pred_cpgs, se$disease,se$`sample type:ch1`),
                        getSP(pred_cpgs_filt, se$disease,se$`sample type:ch1`)),
                 SN_CHARGE = c(getSN(pred_cpgs, se$disease,se$`sample type:ch1`, 2),
                               getSN(pred_cpgs_filt, se$disease,se$`sample type:ch1`, 2)),
                 SN_Kabuki = c(getSN(pred_cpgs, se$disease,se$`sample type:ch1`, 3),
                               getSN(pred_cpgs_filt, se$disease,se$`sample type:ch1`, 3)))

df_cpgs %>% t() %>% kable()
```


```{r}
df_models <- data.frame(models = c("DNN1", "DNN2", "DNN3", "DNN4"),
                        Neurons_gene = c(2, 2, 1, 1),
                        Neurons_chromosome = c(100, 100, 1000, 1000),
                        CpGs_chromosome = c("Intergenic", "All", "Intergenic", "All"),
                        accuracy_layer1 = c(getAccuracy(pred_dnn1_conc, se$disease,se$`sample type:ch1`), 
                              getAccuracy(pred_dnn2_conc, se$disease,se$`sample type:ch1`),
                              getAccuracy(pred_dnn3_conc, se$disease,se$`sample type:ch1`), 
                              getAccuracy(pred_dnn4_conc, se$disease,se$`sample type:ch1`)),
                 SP_layer1 = c(getSP(pred_dnn1_conc, se$disease,se$`sample type:ch1`), 
                              getSP(pred_dnn2_conc, se$disease,se$`sample type:ch1`),
                              getSP(pred_dnn3_conc, se$disease,se$`sample type:ch1`), 
                              getSP(pred_dnn4_conc, se$disease,se$`sample type:ch1`)),
                 SN_CHARGE_layer1 = c(getSN(pred_dnn1_conc, se$disease,se$`sample type:ch1`, 2),
                              getSN(pred_dnn2_conc, se$disease,se$`sample type:ch1`, 2),
                              getSN(pred_dnn3_conc, se$disease,se$`sample type:ch1`, 2), 
                              getSN(pred_dnn4_conc, se$disease,se$`sample type:ch1`, 2)),
                 SN_Kabuki_layer1 = c(getSN(pred_dnn1_conc, se$disease,se$`sample type:ch1`, 3),
                              getSN(pred_dnn2_conc, se$disease,se$`sample type:ch1`, 3),
                              getSN(pred_dnn3_conc, se$disease,se$`sample type:ch1`, 3), 
                              getSN(pred_dnn4_conc, se$disease,se$`sample type:ch1`, 3)),
                 accuracy_dense1 = c(getAccuracy(pred_dnn1_dense1, se$disease,se$`sample type:ch1`), 
                              getAccuracy(pred_dnn2_dense1, se$disease,se$`sample type:ch1`),
                              getAccuracy(pred_dnn3_dense1, se$disease,se$`sample type:ch1`), 
                              getAccuracy(pred_dnn4_dense1, se$disease,se$`sample type:ch1`)),
                 SP_dense1 = c(getSP(pred_dnn1_dense1, se$disease,se$`sample type:ch1`), 
                              getSP(pred_dnn2_dense1, se$disease,se$`sample type:ch1`),
                              getSP(pred_dnn3_dense1, se$disease,se$`sample type:ch1`), 
                              getSP(pred_dnn4_dense1, se$disease,se$`sample type:ch1`)),
                 SN_CHARGE_dense1 = c(getSN(pred_dnn1_dense1, se$disease,se$`sample type:ch1`, 2),
                              getSN(pred_dnn2_dense1, se$disease,se$`sample type:ch1`, 2),
                              getSN(pred_dnn3_dense1, se$disease,se$`sample type:ch1`, 2), 
                              getSN(pred_dnn4_dense1, se$disease,se$`sample type:ch1`, 2)),
                 SN_Kabuki_dense1 = c(getSN(pred_dnn1_dense1, se$disease,se$`sample type:ch1`, 3),
                              getSN(pred_dnn2_dense1, se$disease,se$`sample type:ch1`, 3),
                              getSN(pred_dnn3_dense1, se$disease,se$`sample type:ch1`, 3), 
                              getSN(pred_dnn4_dense1, se$disease,se$`sample type:ch1`, 3)),
                                  accuracy_dense1b = c(getAccuracy(pred_dnn1_dense1b, se$disease,se$`sample type:ch1`), 
                              getAccuracy(pred_dnn2_dense1b, se$disease,se$`sample type:ch1`),
                              getAccuracy(pred_dnn3_dense1b, se$disease,se$`sample type:ch1`), 
                              getAccuracy(pred_dnn4_dense1b, se$disease,se$`sample type:ch1`)),
                 SP_dense1b = c(getSP(pred_dnn1_dense1b, se$disease,se$`sample type:ch1`), 
                              getSP(pred_dnn2_dense1b, se$disease,se$`sample type:ch1`),
                              getSP(pred_dnn3_dense1b, se$disease,se$`sample type:ch1`), 
                              getSP(pred_dnn4_dense1b, se$disease,se$`sample type:ch1`)),
                 SN_CHARGE_dense1b = c(getSN(pred_dnn1_dense1b, se$disease,se$`sample type:ch1`, 2),
                              getSN(pred_dnn2_dense1b, se$disease,se$`sample type:ch1`, 2),
                              getSN(pred_dnn3_dense1b, se$disease,se$`sample type:ch1`, 2), 
                              getSN(pred_dnn4_dense1b, se$disease,se$`sample type:ch1`, 2)),
                 SN_Kabuki_dense1b = c(getSN(pred_dnn1_dense1b, se$disease,se$`sample type:ch1`, 3),
                              getSN(pred_dnn2_dense1b, se$disease,se$`sample type:ch1`, 3),
                              getSN(pred_dnn3_dense1b, se$disease,se$`sample type:ch1`, 3), 
                              getSN(pred_dnn4_dense1b, se$disease,se$`sample type:ch1`, 3)),
                 accuracy_dense2 = c(getAccuracy(pred_dnn1_dense2, se$disease,se$`sample type:ch1`), 
                              getAccuracy(pred_dnn2_dense2, se$disease,se$`sample type:ch1`),
                              getAccuracy(pred_dnn3_dense2, se$disease,se$`sample type:ch1`), 
                              getAccuracy(pred_dnn4_dense2, se$disease,se$`sample type:ch1`)),
                 SP_dense2 = c(getSP(pred_dnn1_dense2, se$disease,se$`sample type:ch1`), 
                              getSP(pred_dnn2_dense2, se$disease,se$`sample type:ch1`),
                              getSP(pred_dnn3_dense2, se$disease,se$`sample type:ch1`), 
                              getSP(pred_dnn4_dense2, se$disease,se$`sample type:ch1`)),
                 SN_CHARGE_dense2 = c(getSN(pred_dnn1_dense2, se$disease,se$`sample type:ch1`, 2),
                              getSN(pred_dnn2_dense2, se$disease,se$`sample type:ch1`, 2),
                              getSN(pred_dnn3_dense2, se$disease,se$`sample type:ch1`, 2), 
                              getSN(pred_dnn4_dense2, se$disease,se$`sample type:ch1`, 2)),
                 SN_Kabuki_dense = c(getSN(pred_dnn1_dense2, se$disease,se$`sample type:ch1`, 3),
                              getSN(pred_dnn2_dense2, se$disease,se$`sample type:ch1`, 3),
                              getSN(pred_dnn3_dense2, se$disease,se$`sample type:ch1`, 3), 
                              getSN(pred_dnn4_dense2, se$disease,se$`sample type:ch1`, 3)))

df_models %>% t() %>% kable()

```


